// Shopping example with correct linear logic syntax
// Demonstrates persistent goals (!), optional facts (?), and main goal

// Define basic types as subtypes of atom
item :: type of atom.
dollar :: type of atom.
customer :: type of atom.

// Define specific items as distinct types of item
bread :: item.
milk :: item.

// Define specific customers as atoms of customer type
alice :: customer.
bob :: customer.

// Define specific money as atoms of dollar type  
dollar1 :: dollar.
dollar2 :: dollar.
dollar3 :: dollar.

// Define predicates for the store inventory
has_item :: item -> type.
has_money :: customer -> dollar -> type.
wants_item :: customer -> item -> type.

// Define the transaction predicate
can_buy :: customer -> item -> dollar -> type.

// Store inventory - persistent facts (always available)
persistent inv1 :: has_item(bread).
persistent inv2 :: has_item(milk).

// Customer money - linear resources (money gets consumed when spent)
m1 :: has_money(alice, dollar1).
m2 :: has_money(alice, dollar2).
?m3 :: has_money(bob, dollar3).

// Customer preferences - some are optional (might not exist)
w1 :: wants_item(alice, bread).
?w2 :: wants_item(alice, milk).
w3 :: wants_item(bob, bread).

// Transaction rule using persistent store inventory
transaction_rule :: 
    has_money($customer, $money) & !has_item($item) & wants_item($customer, $item)
    => can_buy($customer, $item, $money).

// Main goal - Alice can buy bread
main :: can_buy(alice, bread, dollar1).
