// Test nested union types with proper type declarations
type food (fruit (apple | orange) | meat (pork | poultry (chicken | turkey))).
type satisfied.
type happy.

apple1 :: apple.
chicken1 :: chicken.
turkey1 :: turkey.

// Rule
eat :: food -> type.
eat :- food => satisfied.

mood :: satisfied -> type.
mood :- satisfied => happy.

// Query
?- eat, mood.
// returns "true. true. true."